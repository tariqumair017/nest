YT => https://www.youtube.com/watch?v=K_OjtrsJGTk&list=PL5OhSdfH4uDt6iG-qze_Q3qgik6VKHeRU

########################## 
nest-mongodb-mongoose .env 
##########################
PORT=8002
DATABASE_URL=mongodb://127.0.0.1:27017/nest-db
JWT_SECRET=gjyg$%&*!$^*8^hgyu76eryskdtkmdgnrasgzd

########################## 
nest-postgres-prisma .env 
##########################
PORT=8001
DATABASE_URL=postgresql://postgres:password@localhost:5432/nest-db
JWT_SECRET=gjyg$%&*!$^*8^hgyu76eryskdtkmdgnrasgzd

########################## 
nest-postgres-typeorm .env
##########################
PORT=8003
DATABASE_URL=postgresql://postgres:password@localhost:5432/nest-db
JWT_SECRET=gjyg$%&*!$^*8^hgyu76eryskdtkmdgnrasgzd


- Node.js (Run time environment for javascript. We install node.js in our system which will help javascript to run in our system. So conclusion is node.js runtime helps javascript to run out side the browser). 
- Nest.js (Node.js framework for building efficient and scalable server side application. Built in TypeScript. Uses modular architecture for better organization)
- Why need nest when we have express (Simplify development using modern architecture. Provides structured way to build scalable and testable application. Solves limitaions of traditional express apps)
      - Express is unopinionated (structure could be so much complex (It's Unstructured. each developer can create folders and files as per their understanding that makes difficulty to understand each other's code))
      - Nest is opinionated (have a proper defined structure, also provide so much built in support like built-in dependency Injection system, integration with databases, sockets, GraphQL, Microservices and many more built in supports are available)
- npm i -g @nestjs/cli    (nest comes with rebust of cli commands)
- nest new project-name   (cli example to create new nest project)
- Folders
      - .prettierrc  (prettier is a tool for code formatting rules, like remove spaces etc)
      - eslint.config.mjs  (gives warrnings and errors to follows nest.js)
- Decorators 
      - Special functions that add metadata (metadata means to providing special features) to classes or methods 
      - Start with @ symbol as @Get, @Controller 
      - Tell NestJs how to treat the class or method
      - Used for routing, dependency injection, validation, etc
- Dependency Injection 
      - Mechanism where nest framework automatically provides the required dependencies without creating them manually
      - eg: constructor(private readonly userService: UserService) {}    (injecting UserService in controller or anywhere as userService)
      - Make code reuseable and clean. Improve readability and maintainability
      - Make testing easy
- API (Application Programming Interface)
      - Allow two applications to talk to each other
      - Bridge between frontend and backend
- REST API (Representational State Transfer) 
      - API that follow certain rules
      - Use HTTP methods like GET, POST, Delete
      - Simple, scalable and stateless communication (Stateless means no need to store anything, request generate hoi, response howa no storage use, nothing)
- DTO (Data Transfer Object)
      - Provide security and validation
      - Use to define the shape of incoming request data (ensures only required data is passed)
- Interface (It's a Typescript)
      - Define the structure (type) of object
      - Write clean, structured, type-safe code
      - Used for both request (DTOs) and response objects
- Important (Only dto never works in runtime because on runtime typescript types and classes are removed. So we will use class-validator and class-transformer)
      - class-validator: It validates typescript classes properties by decorators
      - class-transformer: Helps to convert plain json object (frontend request data) to class instances so that class-validator can validate. Because class-validator only validate class instances not json objects
- Custom Pipes: Mostly used in main.ts Example: app.useGlobalPipes()
      - Pipes are used to transform or validate incoming data (Nest allow you to create your own pipes) or business logic filtering
     Imp - Pipe runs before the data hits the route handler controller method (Global pipes in main.ts, also can  create controller level pipes)
      - Best practice "nest g pipe common/pipes/uppercase"
- Protect Routes Guards
      - Guards are classes that implement logic to decide whether a request is allowed or not 
      - Implement by CanActivate interface
      - Mostly used for Authentication and Authorization
- Exception Filters  (nest g filter filters/http-exception)
      - Handle errors and exceptions in a centralized way
      - Can be apply at method level, controller level, or globally (main.ts)
      - @catch() decorator is used to defined which exception the filter will handle 
- Middleware (Middleware vs Guard)
      - Middleware is afunction which runs before request reach to controller
      - Use cases:
          - Logging the request
	  - Auth token (like jwt)
	  - Request transformation (like converting string to number)
	  - Blocking, redirecting requests
	  - Setting headers 
      - Middleware vs Guard:
          - Guard is a nest.js concept (can't use in express, It's advance concept used in nest.js) and Middleware is express.js concept
	  - Can not use decorators in Middleware as It's a express.js concept
      - Guard:
	  - Before route is accessed (based on auth), authorization (role check, access allowed)
      - Middleware:
	  - Before controller, common tasks (logging, token decode)

- Lifecycle Events (also called "special methods", "lifecycle methods", "Hooks") (nest will call this special method on a event trigger)
      - Automatically nest.js called at different stages of module/service/component's life
      - Used to perform actions during creation or destruction
      - Helps run some code when app/modulw/service initialized or destroyed.
      - Useful for tasks like DB connections, logging, resource cleanup etc.
      - onModuleInit() => called when a module is initialized, onApplicationShutdown() => called when app is shutting down
- Environment Variables
      - npm i @nestjs/config   (for config environment variables)
      - app.modules.ts => import { ConfigModule } from '@nestjs/config';  => inside imports: [ConfigModule.forRoot({isGlobal: true})]
- Install Mongoose (npm i @nestjs/mongoose mongoose)
- Embedding Relationship (Example: nest-mongodb/src/user [user and address])
- Reference Relationship (Example: nest-mongodb/src/employee employee and profile])


#############################
Nest PostgreSQL with TypeORM
#############################
- Why PostgreSQL when we have other SQL Databases:
	- Power of PostgreSQL (SQL + NOSQL hybrid). It gives power of both SQL and NOSQL in one system.
	- Also support NoSQL features like:
		- JSON & JSONB colums
		- Full text search
		- Array and custom data types
- TypeORM
	- It connects your nest.js app to PostgreSQL using OOP style code
	- We define tables as classes using decorators like @Entity, @Column, etc
	- It makes database queries easier, readable and type-safe 
- Connect Supabase PostgreSQL (YT: https://youtu.be/9vULzFAAxdg?si=Kk-ew-2DlBhiSstd)
- @nestjs/typeorm => @InjectRepository()
	- Tells nest.js which entity will inject to the service
	- export class EmployeeService {
              constructor(
                @InjectRepository(Employee)
                private employeeRepository: Repository<Employee>,
              ) {}
- typeorm => Repository
	- This Repository tells that you can perform crud/db operation on the entity (Employee)
- ExecutionContext (inside auth guard)
	- Tells us about request and response cycle of current request


#######################################
GraphQL (project: nest-graphql-mongodb)
#######################################
- What is GraphQL (modern approach to handle APIs)
	- Developed by Facebook in 2012 (and in 2015 make it open source for everyone)
	- In simple, GraphQL gives controller to request only data from server which client exactly need (nothing more or less)
	- GraphQL is a query language for APIs
	- Solves problems of over-fetching (too much data) and under-fetching (too little data) in REST APIs
		- Example: Getting user profile might return posts, frineds, and settings, even if you just need name. But with GraphQL, you ask only for what you need
		- Thats why we say Its, Faster, flexiable and efficient as compare to REST APIs
	- Works on a single endpoint (single url), not multiple endpoints like REST 
- Why Facebook developed it? when we have REST APIs
	- To overcome over-fetching and under-fetching in REST APIs
- npm i @nestjs/apollo (apollo is Graphql server, It helps to config Nest.js to Graphql)

- In GraphQL, client request will hit to resolver (resolvers are controllers of GraphQL) and then resolver send it to service (as controller dose in simple nest)



#############
Commands
############
npm i -g nest
nest new --skip-git     (nest cli)

nest g mo shared
nest g co shared
nest g s shared
rm -rf src/shared

nest g mo shared --no-spec (-d)
nest g mo shared --dry-run (-d)

Complete Resource:
nest g resource shared --no-spec